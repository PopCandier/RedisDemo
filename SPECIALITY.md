### Redis 的一些高级特性

#### 发布订阅模式

> 列表的局限

之前我们说过列表list可以通过指令rpush和lpop实现消息队列(队尾进队，队头出去)，但是消费者需要不停的调用lpop查看list中是否有需要等待处理的消息，（比如写一个while循环，不停的调用），但是为了减少通信的消耗，可以sleep()一段时间再消费，但是这个地方有两个问题。

* 如果生产者的生产速度远大于消费者的消费速度，那么消息将会堆积，list会占用大量的内存
* redis的引用，是为了提高查询速度，实时性，但是这样不断的sleep就无法保证实时性。

不过我们还知道列表还提供了一个阻塞命令，blpop，没有任何元素可以弹出的时候，连接会被阻塞。

```
blpop queue 5
```

从左边弹出，key为queue的列表，超时时间为5秒，若五秒没有返回那么就会释放连接。但是，这种基于list实现的消息队列，不支持一对多的消息分发。

> 发布订阅模式

redis提供了一组命令实现发布/订阅模式。

订阅者可以获得发布者发布的实时消息，这种方式，发送者和接受者没有直接关联，实现了解耦，接受者不需要持续尝试获取消息，一旦得到订阅者的消息，就会得到反馈。

* 订阅频道

首先，我们有很多的频道( channel )，我们也可以把这个频道理解为queue，订阅者可以订阅一个或者多个频道，消息的发布者（生产者）可以指定给频道发布消息，则意味着我们可以创建多个频道即多个queue，发布者负责从频道存数据，订阅者负责从频道中拿数据。

只要消息到到达了频道，所有的订阅了这个频道的订阅者都会收到这条消息。

![1573457443503](./img/1573457443503.png)



需要注意的是，发出去的消息不会被持久化，因为他已经从队列里面移除了，所以消费者只能收到他们开始订阅这个**频道之后发布的消息**。同时由于不会被持久化也不存在历史记录。

#### 具体使用

订阅者订阅频道，可以一次性订阅多个，比如这个客户端订阅了三个频道。

![1573458657780](./img/1573458657780.png)

开始订阅的同时，这个个订阅者将会进入阻塞状态，等待频道发送消息，且订阅状态下主动取消**无法取消订阅状态**。

然后我们再起一个连接来充当发布者，向指定频道发布消息，只支持一次向一个频道发布消息，并不支持一次向多个频道发送消息。

![1573459204397](./img/1573459204397.png)

当然你希望取消订阅也是完全可以的，不过要退出订阅状态。

```
unsubscribe channel-anime
```

不过目前这个指令，我没操作出来，在退出订阅模式的时候，同时也退出了客户端，意味着之前订阅的可能也不复存在了，那么这时候取消订阅是否还有效果。

> 按照规则（Pattern）订阅频道

```
支持?和*占位符。？代表一个字符,*代表0个或者多个字符
```

消费端1，关注运动信息。任何以sport结尾的命名的频道都会被接受

![1573459974959](./img/1573459974959.png)

消费端2，关注所有新闻。任何以news开头的频道都会被接受，

![1573460073073](./img/1573460073073.png)

消费端3，关注所有天气新闻。必须允许一个随机字符的其他都匹配的news-weather

![1573460224467](./img/1573460224467.png)

生产者，发送三条消息

![1573460491434](./img/1573460491434.png)

这里只匹配到了一条

![1573460629027](./img/1573460629027.png)

如果不匹配自然也不会发送到相关的订阅者

![1573460849085](./img/1573460849085.png)

第二个语句，只有news匹配了，但是只允许匹配一个的`?eather`没有收到新的消息。

一张图总结这个过程。

![1573460984671](./img/1573460984671.png)

> 如果在代码中取消订阅

// todo

---



#### Redis 事务

redis中的为什么需要用到事务，首先事务的这个概念是对一系列crud操作是否原子性的保证，不局限于数据库中的事务。

我们知道redis的单个命令是原子性的，比如，`get、set、mget、mset`，如果涉及到多个命名的时候，需要把多个命名作为一个不可分割到底处理序列，就需要用到事务。

例如我们之前说的用setnx时间分布式锁，我们先set，然后设置对key设置expire，即超时时间，防止del发生异常的时候，锁不会被释放，业务处理完以后在del，这三个动作我们希望他们作为一组命名执行。

Redis的事务涉及四个命名：multi（开启事务），exec（执行事务），discard（取消事务），watch（监视）

##### 事务的用法

我们用一个很常见的转账的例子，pop和pipi各有100块，pop向pipi转账10块。

对于我们来说是在pop的账户上减少10块，在pipi的账户上增加10块。

![1573462219063](./img/1573462219063.png)

通过multi的命名开启事务。事务不能嵌套，多个multi命名效果是一样的。

![1573462387102](./img/1573462387102.png)

multi执行后，客户端可以继续向服务器发送任意多条命名，这些命名不会立即指向，而是放到一个队列中，当exec命名为调用时，所有队列中的命名才会被执行。

![1573462328710](./img/1573462328710.png)

当你开启了一个事务，即使用了multi命名后，必须执行exec后，事务里面囤积在队列里的指令才会被执行，反之，如果你的命名都不会被执行。

![1573462852701](./img/1573462852701.png)

最后mget的结果还是不会变的。

如果你中途想要放弃事务，请使用`discard`，如上图所示，你将会放弃队列中的所有执行，退出事务，放弃执行

> watch 命令

redis里面中还提供了一个watch命名。他可以为redis事务提供cas乐观锁行为（Check and Set/Compare and Swap），也就是多个线程更新变量的时候，会和原值做比较，只有它没有被其他线程修改的情况下，才更新成新的值。

我们可以用watch监视一个或者多个key，如果开启事务之后，至少有一个被监视key键在exec执行之前被修改，那么整个事务都会被取消(key提前过期除外)。可以用unwatch取消。

![1573464445787](./img/1573464445787.png)

所以我们还可以得到一个结论就是，watch的效果只能持续一次事务，无论你的当前设置的事务成功或者失败，下次需要使用都需要重新设置。

> 事务可能遇到的问题

我们把事务执行遇到的问题分为两种，一种是在执行exec之前发生的操作，一种是在执行exec之后发生的错误。也就是在执行事务，入队列时候发生的错误，然后执行事务队列中囤积指令的报错。

* 在执行 exec 之前发生错误
  * 比如入队命名存在语法错误，包括参数数量，参数名等等（编译器错误）![1573465358572](./img/1573465358572.png)这种情况下事务会被拒绝执行，也就是队列中所有的命名都不会得到执行
* 在执行exec之后发生错误
  * ![1573465681105](./img/1573465681105.png)比如，类型错误，比如对 String 使用了 Hash 的命令，这是一种运行时错误。最后我们发现 set k1 1 的命令是成功的，也就是在这种发生了运行时异常的情况下， 只有错误的命令没有被执行，但是其他命令没有受到影响。 这个显然不符合我们对原子性的定义，也就是我们没办法用 Redis 的这种事务机制 来实现原子性，保证数据的一致。

> 为什么在一个事务中存在错误，redis不回滚？

因为redis作者认为事务不应该在redis里面做，而应该在持久层上做。



#### Lua 脚本

lua是一种轻量级脚本语言，它是用C语言编写的，跟数据的存储过程有点类似。使用lua脚本来执行Redis命令的好处：

* 一次发送多个命令，减少网络开销，因为可以变成一个脚本，一口气发送给redis
* redis会将整个脚本作为一个整体执行，不会被其他请求打断，保持原子性。
* 对于复杂的组合命令，我们可以放在文件中，可以实现程序之间命令集复用

在redis中调用lua脚本

```
redis> eval lua-script key-num [key1 key2 key3 ....] [value1 value2 value3 ....]
```

* eval 代表的是执行 Lua语言的命令
* lua-script 代表的是 Lua语言脚本内容
* key-num 表示参数中有多少个key，需要注意的是redis中key是从1开始的，如果没有key的参数，那么写0
* [key1 key2 key3...]是key作为参数传递给lua语言，也可以不填，但是需要和key-num的个数保持一致
* [value1 value2 value3...]这些参数传递给lua语言，他们是可填写，可不填了，填了相当于是全局变量

返回一个字符串，0个参数

![1573479417938](./img/1573479417938.png)

eval是具体的执行lua脚本的指令，后面需要用双引号囊括起来，字符串用单引号，因为我们并没有key传递进去，所以要写0，表示没有参数，是0个。

> 在Lua脚本中调用 Redis 命令

使用redis.call(command,key, [param1,param2]) 进行操作。语言格式。

```
redis> eval "redis.call('set',KEYS[1],ARGV[1])" 1 lua-key lua-value
```

* command 是命令，包括 set、get、del 等命令
* key 是被操作的键
* param1,param2...代表给key的参数

注意跟Java不一样，定义只有形参，调用只有实参。也就是说其实本质调用的是一个单词。

lua是在调用时用key表示形参，argv表示参数值（实参），是两个单词。

![1573480072587](./img/1573480072587.png)

第一个命令等价于直接调用了 `set POP 666`，而第二个等价于直接调用了`hset POP1 a 1`

在redis-cli中直接写lua脚本不够方便，也不能实现编辑和复用，通常我们会把脚本放在文件里，然后执行这个文件。

> 在 Redis 中调用Lua脚本文件中的命令，操作Redis

我们可以现在创建一个文件夹专门放脚本

创建一个文件夹来放这些脚本 `mkdir luascript`

```
vim pop.lua
```

编写lua脚本内容，先设置，再取值。

```lua
redis.call('set',KEYS[1],ARGV[1])
return redis.call('get',KEYS[1])
```

现在我们在redis客户端中调用Lua脚本。

![1573481279919](./img/1573481279919.png)

可以看到脚本很正常的执行了，**但是有一点区别需要注意的是**，如果我们不是用文件的形式存储lua脚本的话，执行的后面的参数是可以比较随意的。也就意味着

```
eval "return 'Hello'..KEYS[1]..ARGV[1]" 1 a 666
```

key与argv之前只需要用空格隔开就可以，但是写成lua脚本后，这样是会报错的，他们有更加严谨的写法，如上面的图所示，原本的参数写法已经不正确，我们在key与argv之间要用空格隔开的同时，还要加上逗号，但是如果是参数的话，只要是空格隔开就可以了。

![1573481807312](./img/1573481807312.png)

lua脚本的写法，和直接文本输入写法有些不同，写的时候，还请注意。

> 对 IP 进行限流

需求：在X秒内只能访问 Y 次。

设计思路：用key记录IP，用value记录访问次数。

拿到IP以后，对IP进行+1。如果是第一次访问，对key设置过期时间（参数1）。否则判断次数，超过限定次数（参数2），返回0。如果没有超过次数则返回1。超过时间，key过期之后，可以再次访问。

KEY[1]是IP，ARGV[1]是过期时间X，ARGV[2]是限制访问次数Y

```lua
-- ip_limit.la
-- IP 限流，对某个IP频率进行限制，6秒钟访问10次

local num = redis.call('incr',KEYS[1])
-- 首先对目标ip进行一次累加
if tonumber(num)==1 then
        -- 将其转化为数字，如果是第一次访问，设置超时时间，并返回1，表示还未被禁止
        redis.call('expire',KEYS[1],ARGV[1])
        return 1
        elseif tonumber(num)>tonumber(ARGV[2]) then
        --当超过指定的超时数目，将会被静止
                return 0
        else
        -- 还未到指定次数
                return 1
end

```

![1573483138617](./img/1573483138617.png)

我们对`app:ip:limit:192.168.0.102`作为键，设置，如果是第一次进去，设置五秒超时时间，在指定时间内，允许3次访问，如果超过三次访问，将会返回0，表示禁止访问，1则还可以接着访问。

![1573483370674](./img/1573483370674.png)

* app:ip:limit:192.168.8.111 是 key 值 ，后面是参数值，中间要加上一个空格 和
  一个逗号，再加上一个 空格 。
  即：./redis-cli –eval [lua 脚本] [key…]空格,空格[args…]

* 多个参数之间用一个 空格 分割 。

  

##### 缓存Lua脚本

> 为什么要缓存

在脚本比较长的情况下，如果每次调用脚本都需要把整个脚本传给 Redis 服务端，
会产生比较大的网络开销。为了解决这个问题，Redis 提供了 EVALSHA 命令，允许开发
者通过脚本内容的 SHA1 摘要来执行脚本。

> 如何缓存

Redis 在执行 script load 命令时会计算脚本的 SHA1 摘要并记录在脚本缓存中，执
行 EVALSHA 命令时 Redis 会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果
找到了则执行脚本，否则会返回错误："NOSCRIPT No matching script. Please use
EVAL.

![1573484260062](./img/1573484260062.png)

需要注意的是，由于生成sha摘要的时候，他并不会去检查是否有语法错误，在执行的时候，才会通过摘要从脚本缓存去寻找，所以编写的时候需要小心。

![1573484354831](./img/1573484354831.png)

> 自乘案例

Redis 有 incrby 这样的自增命令，但是没有自乘，比如乘以 3，乘以 5。 

我们可以写一个自乘的运算，让它乘以后面的参数：

```lua
local curVal = redis.call("get", KEYS[1]) 
	if curVal == false then curVal = 0 
	else curVal = tonumber(curVal) end
	curVal = curVal * tonumber(ARGV[1]) 
redis.call("set", KEYS[1], curVal)
return curVal
```

把这个脚本变成单行，语句之间使用分号隔开 

```lua
local curVal = redis.call("get", KEYS[1]); if curVal == false then curVal = 0 else curVal = tonumber(curVal) end; curVal = curVal * tonumber(ARGV[1]); redis.call("set", KEYS[1], curVal); return curVal
```

script load '命令'

```
127.0.0.1:6379> script load 'local curVal = redis.call("get", KEYS[1]); if curVal == false then curVal = 0 else curVal = tonumber(curVal) end; curVal = curVal * tonumber(ARGV[1]); redis.call("set", KEYS[1], curVal); return curVal'
"be4f93d8a5379e5e5b768a74e77c8a4eb0434441"

127.0.0.1:6379> set num 2 OK 127.0.0.1:6379> evalsha be4f93d8a5379e5e5b768a74e77c8a4eb0434441 1 num 6 (integer) 12
```

