### Redis 的一些高级特性

#### 发布订阅模式

> 列表的局限

之前我们说过列表list可以通过指令rpush和lpop实现消息队列(队尾进队，队头出去)，但是消费者需要不停的调用lpop查看list中是否有需要等待处理的消息，（比如写一个while循环，不停的调用），但是为了减少通信的消耗，可以sleep()一段时间再消费，但是这个地方有两个问题。

* 如果生产者的生产速度远大于消费者的消费速度，那么消息将会堆积，list会占用大量的内存
* redis的引用，是为了提高查询速度，实时性，但是这样不断的sleep就无法保证实时性。

不过我们还知道列表还提供了一个阻塞命令，blpop，没有任何元素可以弹出的时候，连接会被阻塞。

```
blpop queue 5
```

从左边弹出，key为queue的列表，超时时间为5秒，若五秒没有返回那么就会释放连接。但是，这种基于list实现的消息队列，不支持一对多的消息分发。

> 发布订阅模式

redis提供了一组命令实现发布/订阅模式。

订阅者可以获得发布者发布的实时消息，这种方式，发送者和接受者没有直接关联，实现了解耦，接受者不需要持续尝试获取消息，一旦得到订阅者的消息，就会得到反馈。

* 订阅频道

首先，我们有很多的频道( channel )，我们也可以把这个频道理解为queue，订阅者可以订阅一个或者多个频道，消息的发布者（生产者）可以指定给频道发布消息，则意味着我们可以创建多个频道即多个queue，发布者负责从频道存数据，订阅者负责从频道中拿数据。

只要消息到到达了频道，所有的订阅了这个频道的订阅者都会收到这条消息。

![1573457443503](./img/1573457443503.png)



需要注意的是，发出去的消息不会被持久化，因为他已经从队列里面移除了，所以消费者只能收到他们开始订阅这个**频道之后发布的消息**。同时由于不会被持久化也不存在历史记录。

#### 具体使用

订阅者订阅频道，可以一次性订阅多个，比如这个客户端订阅了三个频道。

![1573458657780](./img/1573458657780.png)

开始订阅的同时，这个个订阅者将会进入阻塞状态，等待频道发送消息，且订阅状态下主动取消**无法取消订阅状态**。

然后我们再起一个连接来充当发布者，向指定频道发布消息，只支持一次向一个频道发布消息，并不支持一次向多个频道发送消息。

![1573459204397](./img/1573459204397.png)

当然你希望取消订阅也是完全可以的，不过要退出订阅状态。

```
unsubscribe channel-anime
```

不过目前这个指令，我没操作出来，在退出订阅模式的时候，同时也退出了客户端，意味着之前订阅的可能也不复存在了，那么这时候取消订阅是否还有效果。

> 按照规则（Pattern）订阅频道

```
支持?和*占位符。？代表一个字符,*代表0个或者多个字符
```

消费端1，关注运动信息。任何以sport结尾的命名的频道都会被接受

![1573459974959](./img/1573459974959.png)

消费端2，关注所有新闻。任何以news开头的频道都会被接受，

![1573460073073](./img/1573460073073.png)

消费端3，关注所有天气新闻。必须允许一个随机字符的其他都匹配的news-weather

![1573460224467](./img/1573460224467.png)

生产者，发送三条消息

![1573460491434](./img/1573460491434.png)

这里只匹配到了一条

![1573460629027](./img/1573460629027.png)

如果不匹配自然也不会发送到相关的订阅者

![1573460849085](./img/1573460849085.png)

第二个语句，只有news匹配了，但是只允许匹配一个的`?eather`没有收到新的消息。

一张图总结这个过程。

![1573460984671](./img/1573460984671.png)

> 如果在代码中取消订阅

// todo

---



#### Redis 事务

redis中的为什么需要用到事务，首先事务的这个概念是对一系列crud操作是否原子性的保证，不局限于数据库中的事务。

我们知道redis的单个命令是原子性的，比如，`get、set、mget、mset`，如果涉及到多个命名的时候，需要把多个命名作为一个不可分割到底处理序列，就需要用到事务。

例如我们之前说的用setnx时间分布式锁，我们先set，然后设置对key设置expire，即超时时间，防止del发生异常的时候，锁不会被释放，业务处理完以后在del，这三个动作我们希望他们作为一组命名执行。

Redis的事务涉及四个命名：multi（开启事务），exec（执行事务），discard（取消事务），watch（监视）

##### 事务的用法

我们用一个很常见的转账的例子，pop和pipi各有100块，pop向pipi转账10块。

对于我们来说是在pop的账户上减少10块，在pipi的账户上增加10块。

![1573462219063](./img/1573462219063.png)

通过multi的命名开启事务。事务不能嵌套，多个multi命名效果是一样的。

![1573462387102](./img/1573462387102.png)

multi执行后，客户端可以继续向服务器发送任意多条命名，这些命名不会立即指向，而是放到一个队列中，当exec命名为调用时，所有队列中的命名才会被执行。

![1573462328710](./img/1573462328710.png)

当你开启了一个事务，即使用了multi命名后，必须执行exec后，事务里面囤积在队列里的指令才会被执行，反之，如果你的命名都不会被执行。

![1573462852701](./img/1573462852701.png)

最后mget的结果还是不会变的。

如果你中途想要放弃事务，请使用`discard`，如上图所示，你将会放弃队列中的所有执行，退出事务，放弃执行

> watch 命令

redis里面中还提供了一个watch命名。他可以为redis事务提供cas乐观锁行为（Check and Set/Compare and Swap），也就是多个线程更新变量的时候，会和原值做比较，只有它没有被其他线程修改的情况下，才更新成新的值。

我们可以用watch监视一个或者多个key，如果开启事务之后，至少有一个被监视key键在exec执行之前被修改，那么整个事务都会被取消(key提前过期除外)。可以用unwatch取消。

![1573464445787](./img/1573464445787.png)

所以我们还可以得到一个结论就是，watch的效果只能持续一次事务，无论你的当前设置的事务成功或者失败，下次需要使用都需要重新设置。

> 事务可能遇到的问题

我们把事务执行遇到的问题分为两种，一种是在执行exec之前发生的操作，一种是在执行exec之后发生的错误。也就是在执行事务，入队列时候发生的错误，然后执行事务队列中囤积指令的报错。

* 在执行 exec 之前发生错误
  * 比如入队命名存在语法错误，包括参数数量，参数名等等（编译器错误）![1573465358572](./img/1573465358572.png)这种情况下事务会被拒绝执行，也就是队列中所有的命名都不会得到执行
* 在执行exec之后发生错误
  * ![1573465681105](./img/1573465681105.png)比如，类型错误，比如对 String 使用了 Hash 的命令，这是一种运行时错误。最后我们发现 set k1 1 的命令是成功的，也就是在这种发生了运行时异常的情况下， 只有错误的命令没有被执行，但是其他命令没有受到影响。 这个显然不符合我们对原子性的定义，也就是我们没办法用 Redis 的这种事务机制 来实现原子性，保证数据的一致。

> 为什么在一个事务中存在错误，redis不回滚？

因为redis作者认为事务不应该在redis里面做，而应该在持久层上做。

